# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D0IfdtwVX7KNFLEFR-vzl1o4OJFebTO4
"""

import base64

#-----------------------------------------------
# How to Solve this Roman emperor's cipher?
print("https://www.dcode.fr/caesar-cipher")

#-----------------------------------------------
print("crypto{y0ur_f1rst_fl4g}")

#-----------------------------------------------
# Given hex string
hex_string = "72bca9b68fc16ac7beeb8f849dca1d8a783e8acf9679bf9269f7bf"

# Step 1: Convert hex to bytes
byte_data = bytes.fromhex(hex_string)

# Step 2: Encode the bytes to Base64
base64_encoded = base64.b64encode(byte_data)

# Step 3: Convert bytes to string for readability
base64_string = base64_encoded.decode('ascii')

print(base64_string)
#-----------------------------------------------
# Given array of ASCII codes
ascii_numbers = [99, 114, 121, 112, 116, 111, 123, 65, 83, 67, 73, 73, 95, 112, 114, 49, 110, 116, 52, 98, 108, 51, 125]

# Convert each number to its corresponding ASCII character and join them into a string
flag = ''.join(chr(num) for num in ascii_numbers)

print(flag)

#-----------------------------------------------
# Given hex-encoded flag
hex_flag = "63727970746f7b596f755f77696c6c5f62655f776f726b696e675f776974685f6865785f737472696e67735f615f6c6f747d"

# Convert hex to bytes, then decode to ASCII
flag = bytes.fromhex(hex_flag).decode('ascii')

print(flag)

#-----------------------------------------------

# Given hex string
hex_string = "72bca9b68fc16ac7beeb8f849dca1d8a783e8acf9679bf9269f7bf"

# Step 1: Convert hex to bytes
byte_data = bytes.fromhex(hex_string)

# Step 2: Encode the bytes to Base64
base64_encoded = base64.b64encode(byte_data)

# Step 3: Convert bytes to string for readability
base64_string = base64_encoded.decode('ascii')

print(base64_string)


n = 11515195063862318899931685488813747395775516287289682636499965282714637259206269


# Cadena original
original = "label"

# Aplicar XOR con 13 a cada carácter
xor_result = ''.join([chr(ord(c) ^ 13) for c in original])

# Mostrar el resultado como flag
flag = f"crypto{{{xor_result}}}"
print(flag)



from binascii import unhexlify

# Datos del reto
KEY1_hex = "a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313"
KEY2_KEY1_hex = "37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1e"
KEY2_KEY3_hex = "c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1"
FLAG_ALL_hex = "04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf"

# Convertir de hex a bytes
KEY1 = unhexlify(KEY1_hex)
KEY2_KEY1 = unhexlify(KEY2_KEY1_hex)
KEY2_KEY3 = unhexlify(KEY2_KEY3_hex)
FLAG_ALL = unhexlify(FLAG_ALL_hex)

# XOR function
def xor(a, b):
    return bytes(x ^ y for x, y in zip(a, b))

# Recuperar KEY2
KEY2 = xor(KEY1, KEY2_KEY1)

# Recuperar KEY3
KEY3 = xor(KEY2, KEY2_KEY3)

# Recuperar FLAG (FLAG ^ KEY1 ^ KEY2 ^ KEY3)
FLAG = xor(FLAG_ALL, xor(KEY1, xor(KEY2, KEY3)))

print("FLAG:", FLAG.decode())



#!/usr/bin/env python3
# decode_xor_single_byte.py
# Decodifica una cadena hex que fue XORed con un solo byte (brute force)

import binascii
import string

hex_input = "73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d"

def is_printable(bs):
    # considerar imprimibles los caracteres comunes (espacio..~) y salto de línea/tab si quisieras
    return all(32 <= b <= 126 for b in bs)

def brute_force_xor_single_byte(hex_str):
    data = binascii.unhexlify(hex_str)
    results = []
    for key in range(256):
        decoded = bytes(b ^ key for b in data)
        if is_printable(decoded):
            text = decoded.decode('ascii', errors='replace')
            results.append((key, text))
    return results

if __name__ == "__main__":
    candidates = brute_force_xor_single_byte(hex_input)
    # Mostrar solo los candidatos imprimibles (+ resaltar el que contiene "crypto{")
    for key, text in candidates:
        mark = " <-- posible" if "crypto{" in text else ""
        print(f"key={key:02x} ({key}) : {text}{mark}")




#!/usr/bin/env python3
# decrypt_repeating_xor.py

import binascii

hex_input = "0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104"

# Convertimos de hex a bytes
ct = binascii.unhexlify(hex_input)

# Usamos el prefijo conocido del formato del flag
crib = b"crypto{"

# Recuperamos los primeros bytes de la clave
partial_key = bytes([c ^ p for c, p in zip(ct[:len(crib)], crib)])
print("Clave parcial encontrada:", partial_key)

# Completamos manualmente la clave (del análisis sabemos que es 'myXORkey')
key = b"myXORkey"

# Desencriptamos usando XOR con la clave repetida
pt = bytes(c ^ key[i % len(key)] for i, c in enumerate(ct))
print("Mensaje desencriptado:", pt.decode())